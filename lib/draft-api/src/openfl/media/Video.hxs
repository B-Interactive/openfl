package openfl.media;
import cpp.Pointer;
import cpp.RawPointer;
import cpp.UInt8;
import haxe.io.Bytes;
import haxe.io.BytesData;
import haxe.io.UInt8Array;
import lime.graphics.OpenGLRenderContext;
import openfl.Lib;
import openfl.display.Bitmap;
import openfl.display.BitmapData;
import openfl.display3D.Context3D;
import openfl.display3D.Context3DProgramFormat;
import openfl.display3D.Context3DProgramType;
import openfl.display3D.Context3DTextureFormat;
import openfl.display3D.IndexBuffer3D;
import openfl.display3D.Program3D;
import openfl.display3D.VertexBuffer3D;
import openfl.display3D.textures.RectangleTexture;
import openfl.display3D.textures.Texture;
import openfl.display3D.textures.TextureBase;
import openfl.display3D.textures.VideoTexture;
import openfl.events.Event;
import openfl.events.EventDispatcher;
import openfl.geom.Rectangle;
import openfl.media._internal.GLUtil;
import openfl.media._internal.NativeVideoBackend;
import openfl.net._internal.VoidPointer;
import openfl.utils.ByteArray;
import lime.utils.Float32Array;
import lime.utils.UInt16Array;

/**
 * ...
 * @author Christopher Speciale
 */
@:access(openfl.media._internal.NativeVideoBackend)
class Video extends Bitmap
{

	var texY:RectangleTexture;
	var texUV:RectangleTexture;
	var tex:RectangleTexture;
	var ctx:Context3D;
	static var videoBuffer:Bytes;
	static var rgbVideoBuffer:Bytes;

	public function new()
	{
		super();
		trace(__videoInit());

		rgbVideoBuffer = Bytes.alloc(Std.int(480 * 270 * 4));
		videoBuffer = Bytes.alloc(Std.int(480 * 270 * 1.5));

	}
	var positions:VertexBuffer3D;
	var uvs:VertexBuffer3D;
	var indices:IndexBuffer3D;
	var program:Program3D;

	private function __setup():Void
	{
		// Vertex positions (-1 to 1)
		var posData = new Float32Array([
			-1, -1,
			1, -1,
			-1,  1,
			1,  1
		]);
		positions = ctx.createVertexBuffer(4, 2);
		positions.uploadFromTypedArray(posData, 0);

// UVs (0 to 1)
		var uvData = new Float32Array([
			0, 0,
			1, 0,
			0, 1,
			1, 1
		]);
		uvs = ctx.createVertexBuffer(4, 2);
		uvs.uploadFromTypedArray(uvData, 0);

// Indices (2 triangles)
		indices = ctx.createIndexBuffer(6);
		indices.uploadFromTypedArray(new UInt16Array([0, 1, 2, 2, 1, 3]), 0);

	}

	private function __createProgram():Void
	{
		var vertexShader = "attribute vec2 aPosition;
		attribute vec2 aTexCoord;
		varying vec2 vTexCoord;

		void main() {
		vTexCoord = aTexCoord;
		gl_Position = vec4(aPosition, 0.0, 1.0);
	}";

		var fragmentShader = "precision mediump float;

		uniform sampler2D u_tex0;
		uniform sampler2D u_tex1;

		varying vec2 vTexCoord;

		void main() {
		float y = texture2D(u_tex0, vTexCoord).r;

		vec2 uv = texture2D(u_tex1, vTexCoord).rg;
		float u = uv.r - 0.5;
		float v = uv.g - 0.5;

		float r = y + 1.402 * v;
		float g = y - 0.344136 * u - 0.714136 * v;
		float b = y + 1.772 * u;

		gl_FragColor = vec4(r, g, b, 1.0);
	}";

		program = ctx.createProgram(Context3DProgramFormat.GLSL);
		program.uploadSources(vertexShader, fragmentShader);
		ctx.setProgram(program);
	}

	public function load(path:String):Void
	{
		//trace("load", __videoSoftwareLoad(path, videoBuffer.getData(), 480, 270));
		trace("load", __videoGLLoad(path));

		ctx = Lib.current.stage.context3D;
		tex = ctx.createRectangleTexture(480, 270, BGRA, true);
		texY = ctx.createRectangleTexture(480, 270, null, false);
		texUV = ctx.createRectangleTexture(480, 270, null, false);

		@:privateAccess
		texY.__textureID = NativeVideoBackend.__getTextureIDY();
		@:privateAccess
		texUV.__textureID = NativeVideoBackend.__getTextureIDUV();

		@:privateAccess
		texY.__internalFormat = texY.__format = GLUtil.RED(ctx);
		@:privateAccess
		texUV.__internalFormat = texUV.__format = GLUtil.RG(ctx);

		__createProgram();
		__setup();

		//glGetString(GL_VERSION)
	}

	public function play():Void
	{

		Lib.current.stage.addEventListener(Event.ENTER_FRAME, __onEnterFrame);

		trace( NativeVideoBackend.__getTextureIDY(),  NativeVideoBackend.__getTextureIDUV());
	}

	private function __onEnterFrame(_):Void
	{
		//__videoGLGetFramePixels(480, 270);
		__videoGLUpdateFrame();

		//nv12ToRGBA(videoBuffer, rgbVideoBuffer, 480, 270);
		//displayYPlaneOnly(videoBuffer, rgbVideoBuffer, 480, 270);
		//tex.uploadFromByteArray(rgbVideoBuffer,0);
		//trace(data.length);
		//trace(data.length);
		//tex.uploadFromTypedArray(data, 0);

		ctx.setRenderToTexture(tex, true);
		//ctx.clear(0, 0, 0, 1);

		ctx.setProgram(program);

		ctx.setTextureAt(0, texY);
		ctx.setTextureAt(1, texUV);

		//GLUtil.setUniform(texY, "u_texY", ctx, program, 0);

		//GLUtil.setUniform(texUV, "u_texUV", ctx, program, 1);

		//GLUtil.setUniform("u_texY", ctx, program, 1);
		//GLUtil.setUniform("u_texUV", ctx, program, 2);

		ctx.setVertexBufferAt(0, positions, 0, FLOAT_2); // aPosition
		ctx.setVertexBufferAt(1, uvs, 0, FLOAT_2);       // aTexCoord

		ctx.drawTriangles(indices);
		ctx.setRenderToBackBuffer();

		var currentTexture:TextureBase = tex;
		if (this.bitmapData == null)
		{
			var bmd:BitmapData = BitmapData.fromTexture(currentTexture);
			//var bmd:BitmapData = new BitmapData(480, 270, true, 0x00FFFFFF);
			//bmd.setPixels(new Rectangle(0, 0, 480, 270), rgbVideoBuffer);
			this.bitmapData = bmd;
		}
		else {
			@:privateAccess
			this.bitmapData.__texture = currentTexture;
			this.bitmapData = this.bitmapData;
		}
		//bitmapData.width = 480;
		//bitmapData.height = 270;
		//trace(bitmapData.width, bitmapData.height);
	}

	private static function __videoInit():Bool
	{
		return NativeVideoBackend.__videoInit();
	}

	private static function __videoSoftwareLoad(path:String, buffer:BytesData, length:Int):Bool
	{
		return NativeVideoBackend.__videoSoftwareLoad(path, Pointer.ofArray(buffer), length);

	}

	private static function __videoGLLoad(path:String):Bool
	{
		return NativeVideoBackend.__videoGLLoad(path);

	}

	private static function __videoGLUpdateFrame():Bool
	{
		return NativeVideoBackend.__videoGLUpdateFrame();
	}

	private static function __videoGetFramePixels():Bytes
	{

		return videoBuffer;
	}

	static function nv12ToRGBA(nv12:Bytes, rgba:Bytes, width:Int, height:Int)
	{
		var frameSize = width * height;
		var uvOffset = frameSize + width * 2; // skip first UV row
		var maxUVRows = ((height - 4) >> 1);  // only read UV rows for 270 Y lines

		for (y in 0...height)
		{
			var yRow = y * width;
			var uvRowIndex = (y >> 1);
			if (uvRowIndex >= maxUVRows) continue; // prevent UV overflow

			var uvRow = uvOffset + uvRowIndex * width;

			for (x in 0...width)
			{
				var Y = nv12.get(yRow + x) & 0xFF;
				var U = nv12.get(uvRow + (x & ~1)) & 0xFF;
				var V = nv12.get(uvRow + (x & ~1) + 1) & 0xFF;

				var C = Y - 16;
				var D = U - 128;
				var E = V - 128;

				var R = (298 * C + 409 * E + 128) >> 8;
				var G = (298 * C - 100 * D - 208 * E + 128) >> 8;
				var B = (298 * C + 516 * D + 128) >> 8;

				var rgbaIndex = 4 * (y * width + x);
				rgba.set(rgbaIndex, clamp(B));
				rgba.set(rgbaIndex + 1, clamp(G));
				rgba.set(rgbaIndex + 2, clamp(R));
				rgba.set(rgbaIndex + 3, 255);
			}
		}
	}

	inline static function clamp(v:Int):Int
	{
		return v < 0 ? 0 : (v > 255 ? 255 : v);
	}

	static function displayYPlaneOnly(nv12:Bytes, rgba:Bytes, width:Int, height:Int)
	{
		for (y in 0...height)
		{
			for (x in 0...width)
			{
				var Y = nv12.get(y * width + x);
				var rgbaIndex = 4 * (y * width + x);
				rgba.set(rgbaIndex, Y);
				rgba.set(rgbaIndex + 1, Y);
				rgba.set(rgbaIndex + 2, Y);
				rgba.set(rgbaIndex + 3, 255);
			}
		}
	}
}